/ La programación funcional es un estilo de programación donde las soluciones son funciones simples y aisladas, sin efectos secundarios fuera del alcance de la función:INPUT -> PROCESS -> OUTPUT
// La programación funcional se trata de:
// Funciones aisladas: no depende del estado del programa, que incluye variables globales que están sujetas a cambios.
// Funciones puras: la misma entrada siempre da la misma salida
// Funciones con efectos secundarios limitados: cualquier cambio o mutación en el estado del programa fuera de la función se controla cuidadosamente

//map método que maneja los detalles de iterar sobre una matriz

//El map:
//método itera sobre cada elemento de una matriz y devuelve una nueva matriz que contiene los resultados de llamar a la función de devolución de llamada en cada elemento. Hace esto sin mutar la matriz original.
Array.prototype.map();

//Cuando se utiliza la devolución de llamada, se pasan tres argumentos. El primer argumento es el elemento actual que se está procesando. El segundo es el índice de ese elemento y el tercero es la matriz sobre la que mapse llamó al método.

const names = users.map(user => user.name);//esta lo que hace es buscar los nombre de los usuarios en el array creado a un archivo de texto
console.log(names);

// de esta manera el mapeo es con texto
const ratings = watchList.map(({ Title: title, imdbRating: rating }) => ({title, rating}));
//o tambien asi
const ratings1 = watchList.map(item => ({
    title: item["Title"],
    rating: item["imdbRating"]
  }));

// --------------------------------------------------------------------------------------------------------------------
//Creacion de nuestro propio map
// The global variable
const s = [23, 65, 98, 5];

Array.prototype.myMap = function(callback) {//funcion de creacion 1
  const newArray = [];
//----------------------------------------------
  for (let i = 0; i < this.length; i++) {
    newArray.push(callback(this[i]));
  }
//----------------------------------------------
this.forEach(a => newArray.push(callback(a)));
  return newArray;
};

//-----------------------------------

Array.prototype.myMap = function(callback, arr = [], i = 0) {//funcion de creacion 2 , esta ya se va un toqie a la mierda pero bueno
    return i < this.length
      ? this.myMap(callback, arr.concat(callback(this[i])), i + 1)
      : arr;
  };

const new_s = s.myMap(function(item) {
  return item * 2;
});
// --------------------------------------------------------------------------------------------------------------------


//Filtros:filterllama a una función en cada elemento de una matriz y devuelve una nueva matriz que contiene solo los elementos para los que devuelve esa función true
//La función de devolución de llamada acepta tres argumentos. El primer argumento es el elemento actual que se está procesando. El segundo es el índice de ese elemento y el tercero es la matriz sobre la que filterse llamó al método.
//sintaxis:
const usersUnder30 = users.filter(user => user.age < 30);//filtra a solo los usuarios mayores a 30


//union entre un map y filter
const filteredList = watchList.map(({Title: title , imdbRating: rating}) => ({title , rating})).filter(a => a.rating >= 8);


// -----------------------------------------------------------------------------------------------
//recude:
// Array.prototype.reduce(), o simplemente reduce(), es la más general de todas las operaciones de matriz en JavaScript. Puede resolver casi cualquier problema de procesamiento de matriz utilizando el reducemétodo
//el reducemétodo itera sobre cada elemento de una matriz y devuelve un único valor (es decir, cadena, número, objeto, matriz). Esto se logra a través de una función de devolución de llamada que se llama en cada iteración.
// La función de devolución de llamada acepta cuatro argumentos. El primer argumento se conoce como el acumulador, al que se le asigna el valor de retorno de la función de devolución de llamada de la iteración anterior, el segundo es el elemento actual que se está procesando, el tercero es el índice de ese elemento y el cuarto es la matriz en la que reducese encuentra . 
//Además de la función de devolución de llamada, reducetiene un parámetro adicional que toma un valor inicial para el acumulador. Si no se utiliza este segundo parámetro, la primera iteración se omite y la segunda iteración pasa al primer elemento de la matriz como acumulador.
//ejemplos:

const users = [
    { name: 'John', age: 34 },
    { name: 'Amy', age: 20 },
    { name: 'camperCat', age: 10 }
  ];
  
const sumOfAges = users.reduce((sum, user) => sum + user.age, 0);
  console.log(sumOfAges);
//La consola mostraría el valor 64.

  const usersObj = users.reduce((obj, user) => {
    obj[user.name] = user.age;
    return obj;
  }, {});
  console.log(usersObj);
//La consola mostraría el valor { John: 34, Amy: 20, camperCat: 10 }.

// -----------------------------------------------------------------------------
//despues esta el metodo every el cual es una formas practiva yrapida de ver si todos los areglos de un array cumple con una caracteristica ne comun:
//esta es la sintexis: este seria mas parecido a un &&(and o y), luego tenemos al some que es igual pero funciona como un ||(o o or); estos retornan valores boolenaos
numeros = [10,20,40];

function comprovadorM10(arr){
    return arr.every(n => n>10);
};//esta retorn falso ya no todos lo snumero son mayorees a 10;
//esta es otro sintxis:
function comprovadorM9(arr){
    return arr.every(function(n){
        return n>9;
    });
}//en este caso esta daria verdadera ya que todos los numeros son mayores a 9;

//luego podemos enccontrar al operador some que funciona de la misma manera que el every. cmabia en casi nada soloq que en ves se ser como un and es coomo un or
function comprovadorM11(arr){
    return arr.some(n => n>10);
};//esta retorn falso ya no todos lo snumero son mayorees a 10;
//esta es otro sintxis:
function comprovadorM12(arr){
    return arr.some(function(n){
        return n>9;
    });
}

console.log(comprovadorM9(numeros) + "\n"+ comprovadorM10(numeros) + "\n"+ comprovadorM11(numeros) + "\n"+ comprovadorM12(numeros))

// -----------------------------------------------------------------------------------------------------------
// Introducción al Curry y Aplicación Parcial
//aunq no creas esto funciona, ya que todas son llamas interna s , es un despelota peropara funciones grande y de intertimep sirven bien.

function add(x) {
    // Only change code below this line
   return function add(y){
      return function add(z)
      {
        return z + y + x;
      }
    }
  
    // Only change code above this line
  }
  
  add(10)(20)(30);

// otro ejemplo: 
// //node codigos/ejecucion.js

function sumaLoca(x , y){
    return function sumaLoca(z , a){
        z *= 10;
        return function sumaLoca(b , c){
            b -= c;
            c *= 2;
            return function sumaLoca(d , e){
                d /= e;
                d += 9;
                return x+y+z+a+b+c+d+e;
            }
        }
    }
}

console.log(sumaLoca(10, 10)(1, 10)(10, 10)(10, 10));
